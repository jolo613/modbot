const {MessageEmbed, MessageAttachment} = require("discord.js");

const con = require("../../database");

const errorEmbed = message => {
    return {content: ' ', embeds: [new MessageEmbed()
            .setTitle("Error:")
            .setDescription(message)
            .setColor(0xed3734)], ephemeral: true};
}

const formatDate = date => {
    return date.toISOString().replace(/T/, ' ').replace(/\..+/, '');
}

const command = {
    data: {
        name: 'chatdump'
        , description: 'Dumps a chat log file following the given queries'
        , options: [
            {
                type: 3,
                name: "streamer",
                description: "Search by Streamer username",
                required: false,
                autocomplete: true,
            },
            {
                type: 3,
                name: "user",
                description: "Search by Chatter username",
                required: false,
                autocomplete: true,
            },
            {
                type: 10,
                name: "start",
                description: "Relative start time for chat logs, in hours. Ex: 1 would search for anything less than 1 hour ago",
                required: false,
            },
            {
                type: 10,
                name: "end",
                description: "Relative end time for chat logs, in hours. Ex: 1 would search for anything greater than 1 hour ago",
                required: false,
            },
            {
                type: 4,
                name: "limit",
                description: "Maximum chat messages to be sent. Default/Maximum: 10,000/500,000",
                min_value: 1,
                max_value: 500000,
                required: false,
            },
            {
                type: 5,
                name: "ephemeral",
                description: "'True' if you only want the dump to be viewable by you. Default: True",
                required: false,
            },
        ]
        , default_permission: false
    },
    global: false,
    async execute(interaction) {
        let streamer = interaction.options.getString("streamer", false);
        let user = interaction.options.getString("user", false);
        let start = interaction.options.getNumber("start", false);
        let end = interaction.options.getNumber("end", false);
        let limit = interaction.options.getInteger("limit", false);

        let ephemeral = interaction.options.getBoolean("ephemeral", true);

        if (ephemeral === undefined || ephemeral === null) ephemeral = true;

        try {
            if (streamer) {
                let streamers = await global.api.Twitch.getUserByName(streamer);
                if (streamers.length > 0) {
                    streamer = streamers[0].id;
                } else {
                    throw "No users were found with that username!";
                }
            }
        } catch (err) {
            console.error(err);
            interaction.reply(errorEmbed("Invalid streamer was given: " + err))
            return;
        }
        try {
            if (user) {
                let users = await global.api.Twitch.getUserByName(user);
                if (users.length > 0) {
                    user = users[0].id;
                } else {
                    throw "No users were found with that username!";
                }
            }
        } catch (err) {
            console.error(err);
            interaction.reply(errorEmbed("Invalid user was given: " + err))
            return;
        }

        let queryWhere = "";
        let queryObjs = [];

        const add = (query, obj) => {
            if (queryWhere !== "") queryWhere += " and ";
            queryWhere += query;
            queryObjs = [
                ...queryObjs,
                obj,
            ]
        }

        if (streamer) {
            add("streamer_id = ?", streamer);
        }
        if (user) {
            add("user_id = ?", user);
        }
        if (start) {
            add("timesent > ROUND(UNIX_TIMESTAMP(CURTIME(4)) * 1000) - ?", start * 60 * 60 * 1000);
        }
        if (end) {
            add("timesent < ROUND(UNIX_TIMESTAMP(CURTIME(4)) * 1000) - ?", end   * 60 * 60 * 1000);
        }
        if (!limit) {
            limit = 500000;
        }

        queryObjs = [
            ...queryObjs,
            limit
        ];

        await interaction.deferReply({ephemeral: ephemeral});

        con.query(`select * from twitch__chat ${queryWhere === "" ? "" : "where "}${queryWhere} order by timesent desc${limit ? " limit ?" : ""};`, queryObjs, async (err, res) => {
            if (err) {
                console.error(err);
                interaction.editReply(errorEmbed("An error occurred!"));
            }

            let str = "";

            let header = "= Chat Dump generated by " + interaction.user.username + "#" + interaction.user.discriminator + " on " + formatDate(new Date()) + " =";

            str += "=".repeat(header.length) + "\n" + header + "\n" + "=".repeat(header.length) + "\n\n";

            for (let i = 0; i < res.length; i++) {
                let log = res[i];
                let streamer = await global.api.Twitch.getUserById(log.streamer_id);
                let user = await global.api.Twitch.getUserById(log.user_id);
                str += formatDate(new Date(log.timesent)) + " [#" + streamer.display_name.toLowerCase() + "] " + user.display_name + ": " + log.message + "\n";
            }
            
            const attachment = new MessageAttachment(Buffer.from(str, 'utf-8'), "dump-" + Date.now() + ".txt", {description: "Stuff!", content_type: "text/plain"});
            
            interaction.editReply({content: ' ', ephemeral: ephemeral, files: [attachment]});
        });
    }
};

module.exports = command;